import numpy as np
import matplotlib.pyplot as plt


class DataAssimilation:
    def __init__(
        self,
        single_image_path,
        model,
        obs_path,
        data_R_path,
        data_B_path,
        obs_index=0,
        W_R=1,
        W_B=1,
        latent_shape=100,
    ):
        """
        This class is designed for data assimilation processes, specifically to merge model predictions
        with observations to enhance the accuracy of the predicted data. It applies statistical methods
        to reconcile differences between observed data and model-generated data, using Kalman filtering
        techniques to update predictions.

        Parameters:
            single_image_path (str): Path to the numpy file containing a single image generated by the model.
            model (object): The compression/decompression model used for encoding and decoding the data.
            obs_path (str): Path to the numpy file containing the true observational data.
            data_R_path (str): Path to the numpy file used to calculate the error covariance matrix R.
            data_B_path (str): Path to the numpy file used to calculate the error covariance matrix B.
            obs_index (int): Index of the specific observation image from the dataset to perform data assimilation. Defaults to 0.
            W_R (float): Weight for the error covariance matrix R. Defaults to 1.
            W_B (float): Weight for the error covariance matrix B. Defaults to 1.
            latent_shape (int): The size of the latent space after data compression. Defaults to 100.

        Methods:
            covariance_matrix(X): Calculates the covariance matrix of the given matrix X.
            get_K(): Computes the Kalman Gain matrix using the error covariance matrices R and B.
            get_delta(): Computes the difference between the reduced observation and the reduced model-generated image.
            assimilate(): Performs the data assimilation using the Kalman Gain and delta to update the model-generated image.
            get_assimilated_data(): Returns the assimilated data in the original space.
            get_assimilated_data_reduced(): Returns the assimilated data in the reduced latent space.
            mse(y_obs, y_pred): Computes the mean squared error between observed and predicted data.
            print_mse(): Prints the mean squared errors before and after data assimilation.
            plot_obs_image(): Plots the original observation image.
            plot_predicted_image(): Plots the original model-generated image.
            plot_fixed_predicted_image(): Plots the updated model-generated image after data assimilation.

        Usage:
            - This class is useful in scenarios where model predictions need to be refined based on actual observed data, such as in weather forecasting, remote sensing, or environmental modeling.
        """

        # Load data and model
        self.single_image = np.load(single_image_path)
        self.model = model
        self.obs_data = np.load(obs_path)
        self.obs_index = obs_index
        self.W_R = W_R
        self.W_B = W_B
        self.data_R = np.load(data_R_path)
        self.data_B = np.load(data_B_path)  # generated_images
        self.latent_shape = latent_shape

        # Compress the selected images
        self.all_obs_reduced = self.model.encode(self.obs_data)  # (5,256,256)
        self.single_obs_reduced = self.model.encode(
            self.obs_data[obs_index]
        )  # (256,256)
        self.single_image_reduced = self.model.encode(self.single_image)  # (256,256)

        self.data_R_reduced = self.model.encode(self.data_R)
        self.data_B_reduced = self.model.encode(self.data_B)

        if self.model.get_model_type() == "PCA":
            # Calculate R and B (observation and background error covariance matrix)
            self.R_0 = self.covariance_matrix(self.data_R_reduced.T)
            self.B_0 = self.covariance_matrix(self.data_B_reduced.T)

            self.R = np.diag(np.diag(self.R_0 * self.W_R))
            self.B = np.diag(np.diag(self.B_0 * self.W_B))

        else:
            self.R = (
                self.covariance_matrix(self.data_R_reduced.T)
                + np.eye(self.latent_shape) * self.W_R
            )
            self.B = (
                self.covariance_matrix(self.data_B_reduced.T)
                + np.eye(self.latent_shape) * self.W_B
            )

    def covariance_matrix(self, X):
        means = np.array([np.mean(X, axis=1)]).transpose()
        dev_matrix = X - means
        res = np.dot(dev_matrix, dev_matrix.transpose()) / (X.shape[1] - 1)
        return res

    def get_K(self):
        # Compute the Kalman Gain matrix K
        self.K = self.B @ np.linalg.inv(self.B + self.R)
        return self.K

    def get_delta(self):
        # Compute the delta between reduced observations and background
        self.delta = (self.single_obs_reduced - self.single_image_reduced).squeeze()
        return self.delta

    def get_B(self):
        return self.B

    def get_R(self):
        return self.R

    def get_R_0(self):
        return self.R_0

    def get_B_0(self):
        return self.B_0

    def get_data_R_reduced(self):
        return self.data_R_reduced

    def get_data_B_reduced(self):
        return self.data_B_reduced

    def assimilate(self):

        K = self.get_K()

        delta = self.get_delta()

        # Apply the Kalman Gain to get the updated background in reduced space
        fixed_image_reduced_delta = K @ delta
        self.fixed_image_reduced = (
            self.single_image_reduced + fixed_image_reduced_delta
        ).reshape(1, self.latent_shape)

        # Use model to transform back to the original space
        self.fixed_image = self.model.decode(self.fixed_image_reduced)

    def get_assimilated_data(self):
        return self.fixed_image

    def get_assimilated_data_reduced(self):
        return self.fixed_image_reduced

    def mse(self, y_obs, y_pred):
        return np.mean((y_obs - y_pred) ** 2)

    def print_mse(self):
        # Compute MSE
        self.mse_reduced_after_da = self.mse(
            self.fixed_image_reduced, self.single_obs_reduced
        )
        self.mse_full_after_da = self.mse(
            np.round(np.clip(self.fixed_image, 0, 1)), self.obs_data[self.obs_index]
        )
        self.mse_reduced_before_da = self.mse(
            self.single_image_reduced, self.single_obs_reduced
        )
        self.mse_full_before_da = self.mse(
            self.single_image, self.obs_data[self.obs_index]
        )

        print("MSE (reduced before da):", self.mse_reduced_before_da)
        print("MSE (full before da):", self.mse_full_before_da)
        print("MSE (reduced after da):", self.mse_reduced_after_da)
        print("MSE (full after da):", self.mse_full_after_da)

    def plot_obs_image(self):
        plt.imshow(self.obs_data[self.obs_index].reshape(256, 256), cmap="gray")
        plt.title("Original Observation")
        plt.colorbar()  # Optional, adds a color bar to explain the color mapping
        plt.axis("off")  # Hide the axes
        plt.show()

    def plot_predicted_image(self):
        plt.imshow(self.single_image.reshape(256, 256), cmap="gray")
        plt.title("Original Generated")
        plt.colorbar()  # Optional, adds a color bar to explain the color mapping
        plt.axis("off")  # Hide the axes
        plt.show()

    def plot_fixed_predicted_image(self):
        # Normalize the image data to 0-1
        normalized_image = (self.fixed_image[0] - np.min(self.fixed_image[0])) / (
            np.max(self.fixed_image[0]) - np.min(self.fixed_image[0])
        )

        # Binarize the image: set values < 0.5 to 0, and values >= 0.5 to 1
        binarized_image = np.where(normalized_image < 0.5, 0, 1)

        # Plot the binarized image
        plt.imshow(binarized_image, cmap="gray")  # Use gray scale for binary images
        plt.title("Image After Data Assimilation")
        plt.colorbar()  # Optional, adds a color bar to explain the color mapping
        plt.axis("off")  # Hide the axes
        plt.show()

    def save_predicted_image(self, save_path):
        normalized_image = (self.fixed_image[0] - np.min(self.fixed_image[0])) / (
            np.max(self.fixed_image[0]) - np.min(self.fixed_image[0])
        )
        self.binarized_image = np.where(normalized_image < 0.5, 0, 1)
        np.save(save_path, self.binarized_image.reshape(256, 256))
